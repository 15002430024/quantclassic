# REQ-006: 回测框架收益频率错配与因子截面分散度不足

**创建时间**: 2026-02-06 16:20  
**状态**: ✅ 已完成  
**严重程度**: 🔴 致命 + 🟡 重要

---

## 1. 需求背景

用户反馈动态图模型回测存在三个异常：
1. 回测 15 个窗口，但"只有 2023 年后的数据有值"。
2. 最大回撤极大（long -99.99%, short -100%, long_short -90.17%），但因子 IC 看似合理（IC=0.05, ICIR=0.60, 胜率 75%）。
3. 分组收益不明显，怀疑回测框架或因子至少存在一处问题。

## 2. 诊断结果

### 🔴 致命 BUG-1: 收益列频率错配（10日收益被当作日收益逐日复利）

**已确认证据**:

```
future_return 完全匹配 y_ret_10d（15 行全部 MATCH），不匹配 y_ret_1d（全部 DIFF）
```

| 日期 | future_return | y_ret_10d | y_ret_1d |
|------|:---:|:---:|:---:|
| 2010-10-26 | -0.013299 | -0.013299 ✅ | -0.013299 |
| 2010-10-27 | -0.005416 | -0.005416 ✅ | 0.009447 ❌ |
| 2010-10-28 | -0.078737 | -0.078737 ✅ | 0.017345 ❌ |
| 2010-11-03 | -0.120220 | -0.120220 ✅ | 0.005254 ❌ |

**问题机制**:

`future_return` = `y_ret_10d`（未来10个交易日的累计收益率），但回测框架 `portfolio_builder.py` 的三个组合构建方法（`create_long_portfolio` / `create_short_portfolio` / `create_long_short_portfolio`）均按如下逻辑逐 `trade_date` 计算：

```python
# portfolio_builder.py L137
portfolio_return = (top_stocks[return_col] * weights).sum()  # 每日取当日的10d收益

# portfolio_builder.py L149
long_df['cum_return'] = (1 + long_df['portfolio_return']).cumprod() - 1  # 逐日复利
```

**后果（数学推导）**:

| 组件 | 代码假设 | 实际数据 | 错误放大倍数 |
|------|---------|---------|:---:|
| 逐日复利 | `return_col` = 日收益 | `return_col` = 10日累计收益 | 指数级 |
| 年化收益 | `R^(252/N)` (N=天数) | 应为 `R^(25.2/N)` | ~10x 指数 |
| 年化波动率 | `σ × √252` | 应为 `σ × √25.2` | ~3.16x |
| 夏普比率 | 分子分母均错 | — | 方向不确定 |

**实际产出的荒谬净值**:
```
portfolio_long.csv 最后一行 cum_return = 514,070,117.7（5.14亿倍！）
```

这完美解释了用户观察到的三个现象：
- **年化收益 296%~387%**: 10日收益被逐日复利放大
- **回撤 -99.99%~-100%**: 10日负收益被逐日复利压迫净值至接近0
- **IC 不受影响**: IC 是截面排序相关性，与收益频率无关

**补充说明：rebalance_freq 配置未生效**:

`backtest_system.py` 的 `run_backtest` 方法直接调用 `portfolio_builder.build_portfolios`，该方法内部逐 `trade_date` 遍历，**未使用** `backtest_config.rebalance_freq='biweekly'` 配置。框架中有 `backtest_with_rebalance` 方法支持换仓频率，但 `run_backtest` 主流程没有调用它。

---

### 🟡 重要 BUG-2: 因子截面分散度极低，分组区分力弱

**已确认证据**:

```
因子 factor_raw_std 截面分布统计（3679个交易日）:
  截面均值的均值: -1.762  (负值，被反转过)
  截面标准差的均值: 0.187  (极小)
  截面最大值的均值: -0.663 (所有股票因子值都是负数)
  截面最小值的均值: -1.944
```

因子值集中在 [-2.0, -0.7] 的狭窄区间，截面内标准差仅 0.187，意味着：
- 分组时 top 20% 与 bottom 20% 的因子值差距极小（~0.3）
- 即使排序正确（IC > 0），分组间收益差异微弱
- 这解释了"IC 好但分组不明显"的矛盾

**根因推测**: 模型 64 维多因子输出经 `mean(axis=1)` 聚合后，各因子可能相互抵消，导致集成因子值方差被压缩。

---

### ✅ 已排除: 窗口覆盖问题

**窗口覆盖完全正常**（15个窗口，每窗口253天，2010-2025全覆盖）:

| 窗口 | 日期范围 | 交易日 | 股票数 | 样本量 |
|:---:|---------|:---:|:---:|:---:|
| 1 | 2010-10-26 ~ 2011-11-04 | 253 | 1,923 | 414,487 |
| 2 | 2011-11-04 ~ 2012-11-16 | 253 | 2,181 | 498,912 |
| 3 | 2012-11-16 ~ 2013-12-06 | 253 | 2,357 | 552,321 |
| 4 | 2013-12-06 ~ 2014-12-17 | 253 | 2,439 | 546,165 |
| 5 | 2014-12-17 ~ 2015-12-29 | 253 | 2,595 | 519,546 |
| 6 | 2015-12-29 ~ 2017-01-10 | 253 | 2,758 | 586,057 |
| 7 | 2017-01-10 ~ 2018-01-19 | 253 | 3,120 | 642,267 |
| 8 | 2018-01-19 ~ 2019-02-01 | 253 | 3,378 | 764,531 |
| 9 | 2019-02-01 ~ 2020-02-21 | 253 | 3,450 | 829,172 |
| 10 | 2020-02-21 ~ 2021-03-05 | 253 | 3,637 | 860,096 |
| 11 | 2021-03-05 ~ 2022-03-17 | 252 | 4,241 | 964,321 |
| 12 | 2022-03-18 ~ 2023-03-31 | 253 | 4,663 | 1,100,684 |
| 13 | 2023-03-31 ~ 2024-04-17 | 253 | 5,088 | 1,208,131 |
| 14 | 2024-04-17 ~ 2025-05-06 | 253 | 5,152 | 1,265,060 |
| 15 | 2025-05-06 ~ 2025-12-11 | 151 | 5,090 | 758,508 |

"只有 2023 年后有值" 的视觉印象是因为前期净值过小（接近0后复利爆炸），在图表上被后期天文数字净值压缩为一条贴近 x 轴的直线。

---

## 3. 解决方案

### 3.1 BUG-1 修复方案（收益频率错配）

有三种互斥方案，按推荐程度排列：

#### 方案 A（推荐）: Notebook 侧改用 `y_ret_1d` 作为 `future_return`

```python
# Cell 13 步骤5 中，修改读取的收益列
return_col_name = 'y_ret_1d'   # ← 改为日收益率
needed_cols = ['trade_date', 'order_book_id', return_col_name]
df_returns = pd.read_parquet(data_path, columns=needed_cols)
df_returns = df_returns.rename(columns={return_col_name: 'future_return'})
```

**优点**: 最小修改，回测框架逻辑不变，年化/波动率/夏普等指标计算和 `rebalance_freq` 兼容  
**缺点**: IC 计算与训练标签（`alpha_label` 基于 `y_ret_10d`）不完全对齐

#### 方案 B: 框架侧支持多日收益率

在 `portfolio_builder.py` 和 `performance_evaluator.py` 中增加 `return_period` 参数：
- 组合构建按 N 日换仓而非逐日
- 年化因子改为 `252/N`
- 波动率改为 `σ × √(252/N)`

**优点**: 框架能力更通用  
**缺点**: 改动范围大，需修改多个文件

#### 方案 C: Notebook 侧转换收益率

```python
# 将10日收益转为等效日收益
df_returns['future_return'] = (1 + df_returns['y_ret_10d']) ** (1/10) - 1
```

**优点**: 保留10日收益的信息  
**缺点**: 近似等效日收益，连续复利10天未必精确还原

### 3.2 BUG-2 改进方案（因子分散度）

1. **保留多因子列**: 回测时使用 `pred_factor_0` ~ `pred_factor_63` 逐因子回测，筛选 IC 最高的 top-K 因子加权集成，而非全部 `mean`
2. **截面标准化**: 回测前对集成因子做截面 z-score，增大分组区分力
3. **FactorProcessor 不跳过**: Cell 14 中将因子列名改为不带 `_std` 后缀（如 `pred_mean`），使回测框架的 winsorize + z-score 流程生效

### 3.3 调仓频率修复

`run_backtest` 主流程应调用 `backtest_with_rebalance` 而非逐日遍历的 `build_portfolios`，或在 `build_portfolios` 内部根据 `rebalance_freq` 筛选调仓日期。

## 4. 需要修改的文件

| 文件路径 | 修改类型 | 优先级 | 修改说明 |
|---------|---------|:---:|---------|
| `notebook/lstm+attention12011427.ipynb` Cell 13 | 修改 | 🔴 P0 | 步骤5将 `return_col_name` 从 `'y_ret_10d'` 改为 `'y_ret_1d'`（方案A） |
| `backtest/portfolio_builder.py` | 修改 | 🟡 P1 | `build_portfolios` 增加 `rebalance_freq` 支持，或在 `run_backtest` 中改调 `backtest_with_rebalance` |
| `backtest/backtest_system.py` | 修改 | 🟡 P1 | `run_backtest` 方法对接 `rebalance_freq` 配置到组合构建 |
| `notebook/lstm+attention12011427.ipynb` Cell 14 | 修改 | 🟡 P1 | 因子列名去掉 `_std` 后缀或显式启用 FactorProcessor 截面标准化 |
| `backtest/performance_evaluator.py` | 修改 | 🟢 P2 | （方案B时）增加 `return_period` 参数适配多日收益 |

## 5. 风险与注意事项

1. **方案 A 的 IC 口径不一致**: 训练标签是 `alpha_label`（基于 `y_ret_10d` 的 SimStock 中性化），回测收益改为 `y_ret_1d` 后，IC 评估值会与训练目标略有偏差——但这是合理的（训练看长期排序能力，回测需日频净值曲线）。
2. **10 日收益有重叠**: `y_ret_10d` 在相邻交易日间存在 9 天重叠窗口，逐日复利会产生 autocorrelation 伪收益。即使未来框架支持多日收益（方案B），也应注意去重叠。
3. **因子反转**: Cell 14 检测到 IC < 0 后自动反转因子（`-Val`），这导致因子均值从正变负（~-1.76）。如果因子本身就是"低值好"的方向，强制反转可能不合理——建议在训练侧统一因子方向，回测侧不做自动反转。

## 6. 依赖关系

- **前置条件**: 无额外前置
- **关联需求**: REQ-003（OOM修复）、REQ-004（IC口径修正）、REQ-005（回测时间覆盖）

## 7. 验收标准

1. **BUG-1 修复后**: long 组合年化收益在合理范围（如 5%~30%），最大回撤在 -10%~-50%，cum_return 不出现天文数字
2. **BUG-2 改进后**: 分组收益单调性显著（10组从高到低呈阶梯状），top-bottom 组收益差 > 年化 5%
3. **调仓频率**: 组合换仓频率与配置的 `biweekly` 一致，portfolio_long.csv 行数应为 ~180（而非 3679）

---
*变更记录: 2026-02-06 初始创建*  
*变更记录: 2026-02-06 完成诊断 — 确认致命BUG: y_ret_10d 被当日收益逐日复利 + 因子截面分散度不足 + rebalance_freq 未生效*
